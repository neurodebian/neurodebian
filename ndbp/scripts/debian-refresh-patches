#!/bin/sh

# Version of this script
VERSION=1.0

# TODO: patch(1) can apply patches with fuzz factor. However
# quilt-refresh breaks git-format-patch style patches so
# per-chunk implementation is underway.

# Start of functions

# Usage

print_version() {
	cat <<EOT
neurodebian-import-dsc $VERSION

Copyright: 2024, The NeuroDebian Team <team@neuro.debian.net>
           2024, Vasyl Gello <vasek.gello@gmail.com>


Licensed under GNU Public License version 3 or later.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

EOT
}

print_usage() (
	cat 0<<.a
Usage:
    debian-refresh-patches [--dry-run | --help | --version]

Options:
    --dry-run                    - Do not persist successful changes into
                                   Git repository
    --help                       - Show brief help message
    --version                    - Show version and copyright

Applies patches from 'debian/patches/series', removes the reverse-applicable
ones and commits new patch directory.

.a
)

print_footer() (
	cat 0<<.a
This script is part of NeuroDebian tooling available as NeuroDebian package
'neurodebian-dev' or the upstream repository on Github:

<https://github.com/neurodebian/neurodebian>

To use the newest version of NeuroDebian tooling, please point the environment
variable 'NEURODEBIAN_TOOLING_PATH' to it and add the tools to PATH:

export NEURODEBIAN_TOOLING_PATH="\${PWD}"
export PATH="\${NEURODEBIAN_TOOLING_PATH}:\${PATH}"

.a
)

# Start of script

# Parse command-line options

DRY_RUN=0

case "${1}" in
--dry-run)
	DRY_RUN=1
	;;
-h | --help)
	print_usage
	print_footer
	exit 0
	;;
-v | --version)
	print_version
	exit 0
	;;
esac

# Required tools: sh, git, patch, mv, rm

REQUIRED_TOOLS="git rm"

for _TEMP in ${REQUIRED_TOOLS}; do
	if ! command -v "${_TEMP}" 1>/dev/null 2>&1; then
		echo "ERROR: Required tool ${_TEMP} not found!" >&2
		return 1
	fi
done

unset _TEMP

# Check if NeuroDebian tooling location is overridden via
# NEURODEBIAN_TOOLING_PATH environment variable.

if [ -z "${NEURODEBIAN_TOOLING_PATH}" ]; then
	NEURODEBIAN_TOOLING_PATH="/usr/share/neurodebian"
fi

export NEURODEBIAN_TOOLING_PATH

# Warn if NeuroDebian tooling is not present

if [ ! -d "${NEURODEBIAN_TOOLING_PATH}" ]; then
	cat >&2 0<<.a

ERROR: Can not find NeuroDebian tooling!
ERROR: Paths searched:
ERROR:  - system: /usr/share/neurodebian
ERROR:  - user: ${NEURODEBIAN_TOOLING_PATH}

.a
	return 1
fi

# Include patch file helper

if [ ! -f "${NEURODEBIAN_TOOLING_PATH}/ndbp/helpers/patch-file-helper" ]; then
	echo "ERROR: Can not find rfc822 file helper!" >&2
	return 1
fi

. "${NEURODEBIAN_TOOLING_PATH}/ndbp/helpers/patch-file-helper"

# Exit gracefully if debian/patches/series is not found

if [ ! -d "debian/patches" ] || [ ! -f "debian/patches/series" ]; then
	echo "INFO: Nothing to do!" >&2
	exit 0
fi

# Store current branch tip to reset or err out

if ! BRANCH_HEAD="$(git rev-parse 'HEAD^{commit}')"; then
	echo "ERROR: Can not save the commit at HEAD!" >&2
	exit 1
fi

echo ""
echo "INFO: Processing 'debian/patches/series' ..."
echo ""

# Parse debian/patches/series file

_LINENO=0
_PATCHCOUNT=0
_FAIL=0

PX=""

while read -r _PATCHFILE _NEXT; do
	_LINENO="$((_LINENO + 1))"

	# Skip empty lines and comments

	if [ -z "${_PATCHFILE}" ]; then
		continue
	fi

	case "${_PATCHFILE}" in
	\#*)
		continue
		;;
	esac

	# Check if pX is present: pX is 2nd then comment is 3rd
	# else comment is 2nd

	while read -r _PX _COMMENT; do
		case "${_PX}" in
		-p[0-9])
			PX="${_PX}"
			;;
		\#*)
			:
			;;
		esac
	done 0<<.a
$_NEXT
.a

	# We get patch file - check it and decide what to do next

	echo "INFO: Trying ${_PATCHFILE} ..."

	_PATCHCOUNT="$((_PATCHCOUNT + 1))"
	check_patchfile "${_PATCHFILE}" "${PX}"
	RET=$?
	_FAIL=0

	if [ ${RET} -eq 0 ]; then
		# Patch file applies cleanly - go ahead

		echo "INFO: Patch file '${_PATCHFILE}' applies cleanly!"

		# Continue as no changes to 'debian/patches' should be made
		# at this point

		continue
	elif [ ${RET} -eq 1 ]; then
		# Patch file does not exist - delete the line from d/p/series

		echo "INFO: Patch file '${_PATCHFILE}' does not exist on disk - dropping ..."

		if ! drop_patch_from_series "${_PATCHFILE}"; then
			echo "ERROR: Can not edit debian/patches/series in-place!" >&2
			_FAIL=1
		fi
	elif [ ${RET} -eq 2 ]; then
		# Patch file applies reversibly - delete both line and the file

		echo "INFO: Patch file '${_PATCHFILE}' applies reversibly - dropping ..."

		# Also decrement PATCHCOUNT
		_PATCHCOUNT="$((_PATCHCOUNT - 1))"

		if ! drop_patch_from_series "${_PATCHFILE}"; then
			echo "ERROR: Can not edit debian/patches/series in-place!" >&2
			_FAIL=1
		fi

		if ! rm "debian/patches/${_PATCHFILE}"; then
			echo "ERROR: Can not delete '${_PATCHFILE}'!" >&2
			_FAIL=1
		fi
	elif [ ${RET} -eq 3 ]; then
		# Patch does not apply
		# TODO: split such patch to chunks and try to repair

		echo "ERROR: Patch file '${_PATCHFILE}' does not apply!" >&2

		_FAIL=1
	fi

	# If last operation failed, restore changes

	if [ ${_FAIL} -eq 1 ]; then
		if ! git checkout debian; then
			echo "ERROR: Can not restore changes to debian!" >&2
		fi

		# Stop processing

		break
	fi

	# Commit changes

	if ! git add debian; then
		echo "ERROR: Can not add debian to Git!" >&2
		_FAIL=1
		break
	fi

	if ! git commit -F- 1>/dev/null 0<<.a; then
debian-refresh-patches: Drop patches previously applied

Drop patch '${_PATCHFILE}'
.a
		echo "ERROR: Can not add debian to Git!" >&2
		_FAIL=1
		break
	fi

	echo ""
done \
	0< \
	"debian/patches/series"

# If patch count is zero, delete debian/series altogether

if [ ${_PATCHCOUNT} -eq 0 ]; then
	echo "INFO: Deleting empty 'debian/patches' directory ..."
	echo ""

	if ! git rm -r debian/patches 1>/dev/null 2>&1; then
		echo "ERROR: Can not delete debian/patches !" >&2
		_FAIL=1
	fi

	if ! git commit -F- 1>/dev/null 0<<.a; then
debian-refresh-patches: Drop debian/patches directory

... because no patches left!
.a
		echo "ERROR: Can not add debian/patches to Git!" >&2
		_FAIL=1
	fi

fi

echo ""

# If dry-run is in effect, reset the brnach to saved tip

if [ ${DRY_RUN} -eq 1 ]; then
	echo "INFO: Dry-run requested, restoring original branch state ..."
	echo ""

	if ! git reset --hard "${BRANCH_HEAD}" 1>/dev/null; then
		echo "ERROR: Can not restore branch" >&2
		exit 1
	fi
fi

# If failed, report

if [ ${_FAIL} -ne 0 ]; then
	echo "INFO: Processing of Debian patches failed!"
	echo ""
else
	echo "INFO: Processing of Debian patches completed!"
	echo ""
fi

exit ${_FAIL}
